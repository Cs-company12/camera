<!doctype html>
<html lang="so">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Glass Reveal — Enhanced Filter</title>
<style>
  :root{
    --bg:#0b1220;
    --card:#0f1724;
    --accent:#0ea5a4;
    --muted:#9aa6b2;
  }
  body{
    margin:0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:linear-gradient(180deg,var(--bg),#09101a);
    color:#e6eef3;
    display:flex;
    min-height:100vh;
    align-items:flex-start;
    justify-content:center;
    padding:18px;
    box-sizing:border-box;
  }
  .wrap{
    width:100%;
    max-width:920px;
    display:grid;
    grid-template-columns: 420px 1fr;
    gap:16px;
  }
  .panel{
    background:linear-gradient(180deg,var(--card),#0b1420);
    padding:12px;
    border-radius:12px;
    box-shadow:0 6px 18px rgba(0,0,0,0.6);
    border:1px solid rgba(255,255,255,0.03);
  }
  h1{font-size:18px;margin:0 0 6px}
  p.small{color:var(--muted);font-size:13px;margin:6px 0 12px}
  input[type=file]{display:block;margin-bottom:10px}
  video, canvas {
    width:100%;
    border-radius:10px;
    background:#000;
    display:block;
  }
  .controls{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .control{
    width:100%;
    margin:8px 0;
  }
  label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted)}
  input[type=range]{width:100%}
  .btn{
    display:inline-block;
    padding:8px 12px;
    border-radius:8px;
    background:var(--accent);
    color:#052022;
    font-weight:600;
    cursor:pointer;
    border:none;
  }
  .preset-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
  .row{display:flex;gap:8px;align-items:center}
  .muted{color:var(--muted);font-size:13px}
  footer{margin-top:12px;color:var(--muted);font-size:12px}
  .download {margin-left:auto}
  .canvas-wrap{display:flex;flex-direction:column;gap:8px}
</style>
</head>
<body>
<div class="wrap">

  <div class="panel">
    <h1>Glass Reveal — Live Enhancer</h1>
    <p class="small">Upload sawirka muraayadda — dooro preset ama hagaaji sliders si aad u yara geliso naqshadda iyo shucaaca isla markaana u soo qaado waxa gadaashiisa ku jira.</p>

    <input id="file" type="file" accept="image/*">
    <div class="row" style="margin-bottom:8px">
      <button class="preset-btn" id="preset1">Light</button>
      <button class="preset-btn" id="preset2">Medium</button>
      <button class="preset-btn" id="preset3">Strong</button>
      <button class="btn download" id="download">Download Result</button>
    </div>

    <div style="margin-top:8px">
      <div class="control">
        <label>Exposure <span class="muted" id="expVal">1.15</span></label>
        <input id="exposure" type="range" min="0.6" max="2.2" step="0.01" value="1.15">
      </div>
      <div class="control">
        <label>Contrast <span class="muted" id="contVal">1.35</span></label>
        <input id="contrast" type="range" min="0.5" max="3.5" step="0.01" value="1.35">
      </div>
      <div class="control">
        <label>Desaturate (0 = color, 1 = gray) <span class="muted" id="satVal">0.85</span></label>
        <input id="desat" type="range" min="0" max="1" step="0.01" value="0.85">
      </div>
      <div class="control">
        <label>Highlight Reduce (glare suppression) <span class="muted" id="hVal">0.55</span></label>
        <input id="highlights" type="range" min="0" max="1" step="0.01" value="0.55">
      </div>
      <div class="control">
        <label>Texture Soften (melting pattern) <span class="muted" id="texVal">0.45</span></label>
        <input id="texture" type="range" min="0" max="1" step="0.01" value="0.45">
      </div>
      <div class="control">
        <label>Sharpness Boost <span class="muted" id="shVal">0.9</span></label>
        <input id="sharp" type="range" min="0" max="2.5" step="0.01" value="0.9">
      </div>
    </div>

    <footer>Tip: Haddii iftiinka meesha gadaal ka jiro aad u yar yahay, kordhi <strong>Exposure</strong> &amp; <strong>Contrast</strong>. Haddii reflection xoog badan tahay, kor u qaad <strong>Highlight Reduce</strong>.</footer>
  </div>

  <div class="panel canvas-wrap">
    <div style="display:flex;gap:8px;align-items:center">
      <div style="flex:1">
        <div class="muted">Preview</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="preset-btn" id="reset">Reset</button>
      </div>
    </div>

    <canvas id="output" width="800" height="800"></canvas>

    <p class="muted" style="margin-top:8px">Result will try to suppress reflections and reveal shapes behind textured/frosted glass. Save when satisfied.</p>
  </div>

</div>

<script>
/*
  Glass Reveal — single-file JS
  - Basic image processing in canvas
  - Presets for Light / Medium / Strong
  - Highlight suppression, texture soften, desaturation, exposure/contrast, sharpen
*/

const fileInput = document.getElementById('file');
const canvas = document.getElementById('output');
const ctx = canvas.getContext('2d');

let img = new Image();
let originalImageData = null;
let working = false;

// Controls
const exposureEl = document.getElementById('exposure');
const contrastEl = document.getElementById('contrast');
const desatEl = document.getElementById('desat');
const highlightsEl = document.getElementById('highlights');
const textureEl = document.getElementById('texture');
const sharpEl = document.getElementById('sharp');

const expVal = document.getElementById('expVal');
const contVal = document.getElementById('contVal');
const satVal = document.getElementById('satVal');
const hVal = document.getElementById('hVal');
const texVal = document.getElementById('texVal');
const shVal = document.getElementById('shVal');

function updateLabels(){
  expVal.textContent = parseFloat(exposureEl.value).toFixed(2);
  contVal.textContent = parseFloat(contrastEl.value).toFixed(2);
  satVal.textContent = parseFloat(desatEl.value).toFixed(2);
  hVal.textContent = parseFloat(highlightsEl.value).toFixed(2);
  texVal.textContent = parseFloat(textureEl.value).toFixed(2);
  shVal.textContent = parseFloat(sharpEl.value).toFixed(2);
}

// Preset buttons
document.getElementById('preset1').onclick = ()=> setPreset('light');
document.getElementById('preset2').onclick = ()=> setPreset('medium');
document.getElementById('preset3').onclick = ()=> setPreset('strong');
document.getElementById('reset').onclick = ()=> {
  setPreset('medium');
  if (originalImageData) render();
};

function setPreset(name){
  if(name==='light'){
    exposureEl.value = 1.05;
    contrastEl.value = 1.1;
    desatEl.value = 0.6;
    highlightsEl.value = 0.35;
    textureEl.value = 0.25;
    sharpEl.value = 0.7;
  } else if(name==='medium'){
    exposureEl.value = 1.15;
    contrastEl.value = 1.35;
    desatEl.value = 0.85;
    highlightsEl.value = 0.55;
    textureEl.value = 0.45;
    sharpEl.value = 0.9;
  } else {
    exposureEl.value = 1.35;
    contrastEl.value = 1.9;
    desatEl.value = 1.0;
    highlightsEl.value = 0.75;
    textureEl.value = 0.7;
    sharpEl.value = 1.4;
  }
  updateLabels();
  if(originalImageData) render();
}

setPreset('medium');

[fileInput, exposureEl, contrastEl, desatEl, highlightsEl, textureEl, sharpEl].forEach(el=>{
  el.addEventListener('input', ()=>{
    updateLabels();
    if(originalImageData) render();
  });
});

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = ()=>{
    const maxW = 1400; // keep reasonable size
    const scale = Math.min(1, maxW / img.width);
    canvas.width = Math.round(img.width * scale);
    canvas.height = Math.round(img.height * scale);
    // draw original scaled
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    originalImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    render();
    URL.revokeObjectURL(url);
  }
  img.src = url;
});

// Core render — pipeline style
function render(){
  if(!originalImageData) return;
  // clone
  let w = originalImageData.width, h = originalImageData.height;
  let src = new Uint8ClampedArray(originalImageData.data);
  // 1) Reduce highlights (glare suppression)
  let highlights = parseFloat(highlightsEl.value); // 0..1
  if(highlights>0.02){
    // non-linear highlight suppression: compress high channels
    for(let i=0;i<src.length;i+=4){
      // convert to luminance
      let r = src[i], g = src[i+1], b = src[i+2];
      // perceived luminance
      let L = 0.299*r + 0.587*g + 0.114*b;
      if(L > 220){ // very bright pixel -> compress
        let factor = 1 - (highlights * Math.min(0.9, (L-220)/60));
        src[i] = Math.round(r * factor);
        src[i+1] = Math.round(g * factor);
        src[i+2] = Math.round(b * factor);
      } else if(L > 180){
        let factor = 1 - (highlights * Math.min(0.75, (L-180)/120));
        src[i] = Math.round(r * factor);
        src[i+1] = Math.round(g * factor);
        src[i+2] = Math.round(b * factor);
      }
    }
  }

  // 2) Texture soften (pattern melting) — simple box blur on luminance and blend
  let texture = parseFloat(textureEl.value); // 0..1
  if(texture > 0.02){
    // small separable blur on a luminance map
    let lum = new Float32Array(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let i = (y*w + x)*4;
        lum[y*w + x] = 0.299*src[i] + 0.587*src[i+1] + 0.114*src[i+2];
      }
    }
    // box blur radius depends on texture
    let r = Math.round(1 + texture*6);
    // horizontal pass
    let tmp = new Float32Array(w*h);
    for(let y=0;y<h;y++){
      let sum=0, count=0;
      for(let x=-r;x<=r;x++){
        let xx = Math.min(w-1, Math.max(0, x));
        sum += lum[y*w + xx];
        count++;
      }
      for(let x=0;x<w;x++){
        tmp[y*w + x] = sum / count;
        // slide
        let left = x - r;
        let right = x + r + 1;
        if(left >= 0) { sum -= lum[y*w + left]; count--; }
        if(right < w) { sum += lum[y*w + right]; count++; }
      }
    }
    // vertical pass and blend back to src
    for(let x=0;x<w;x++){
      let sum=0, count=0;
      for(let y=-r;y<=r;y++){
        let yy = Math.min(h-1, Math.max(0, y));
        sum += tmp[yy*w + x];
        count++;
      }
      for(let y=0;y<h;y++){
        let blurred = sum / count;
        let idx = (y*w + x)*4;
        // compute blend factor based on texture setting and pixel luminance
        let origL = 0.299*src[idx] + 0.587*src[idx+1] + 0.114*src[idx+2];
        // if origL is mid/high (where pattern visible), blend more
        let blend = texture * Math.min(1, Math.max(0, (origL - 60)/160));
        // move channels slightly towards blurred luminance (preserve hue a bit)
        let ratio = blend * 0.9;
        let lumDiff = blurred - origL;
        src[idx]   = clamp(src[idx]   + lumDiff * ratio);
        src[idx+1] = clamp(src[idx+1] + lumDiff * ratio);
        src[idx+2] = clamp(src[idx+2] + lumDiff * ratio);
        // slide vertical
        let top = y - r;
        let bottom = y + r + 1;
        if(top >= 0) { sum -= tmp[top*w + x]; count--; }
        if(bottom < h) { sum += tmp[bottom*w + x]; count++; }
      }
    }
  }

  // 3) Desaturate (move towards gray) — you asked neutral/light only
  let desat = parseFloat(desatEl.value); // 0..1, 1->gray
  if(desat > 0.001){
    for(let i=0;i<src.length;i+=4){
      let r = src[i], g=src[i+1], b=src[i+2];
      let gray = Math.round(0.299*r + 0.587*g + 0.114*b);
      src[i]   = clamp( r*(1-desat) + gray*desat );
      src[i+1] = clamp( g*(1-desat) + gray*desat );
      src[i+2] = clamp( b*(1-desat) + gray*desat );
    }
  }

  // 4) Exposure & Contrast & Blue-penetration (slight blue boost to help through glass)
  let exposure = parseFloat(exposureEl.value);
  let contrast = parseFloat(contrastEl.value);
  // contrast function: out = ((in-128)*contrast)+128 then * exposure
  for(let i=0;i<src.length;i+=4){
    for(let c=0;c<3;c++){
      let v = src[i+c];
      v = ((v - 128) * contrast) + 128;
      v = v * exposure;
      src[i+c] = clamp(v);
    }
    // small blue boost (blue penetrates textured glass better visually)
    src[i+2] = clamp(src[i+2] * (1 + (0.06 * (contrast - 1))));
  }

  // 5) Small sharpening pass (unsharp-like)
  let sharp = parseFloat(sharpEl.value); // 0..2.5
  if(sharp > 0.02){
    // create a very small blurred copy (3x3) and subtract
    let blurred = new Uint8ClampedArray(src.length);
    // 3x3 average
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let rc=[0,0,0]; let cnt=0;
        for(let yy=-1;yy<=1;yy++){
          let ny = Math.min(h-1, Math.max(0, y+yy));
          for(let xx=-1;xx<=1;xx++){
            let nx = Math.min(w-1, Math.max(0, x+xx));
            let id = (ny*w + nx)*4;
            rc[0]+=src[id]; rc[1]+=src[id+1]; rc[2]+=src[id+2];
            cnt++;
          }
        }
        let id0 = (y*w + x)*4;
        blurred[id0]   = Math.round(rc[0]/cnt);
        blurred[id0+1] = Math.round(rc[1]/cnt);
        blurred[id0+2] = Math.round(rc[2]/cnt);
        blurred[id0+3] = src[id0+3];
      }
    }
    // sharpen: src + (src - blurred)*amount
    let amount = Math.min(1.6, Math.max(0, (sharp - 0.6)));
    for(let i=0;i<src.length;i+=4){
      src[i]   = clamp( src[i]   + (src[i]   - blurred[i])   * amount );
      src[i+1] = clamp( src[i+1] + (src[i+1] - blurred[i+1]) * amount );
      src[i+2] = clamp( src[i+2] + (src[i+2] - blurred[i+2]) * amount );
    }
  }

  // 6) Final gamma tweak (to avoid clipped whites)
  for(let i=0;i<src.length;i+=4){
    src[i]   = gammaClamp(src[i]);
    src[i+1] = gammaClamp(src[i+1]);
    src[i+2] = gammaClamp(src[i+2]);
  }

  // put back to canvas
  let out = new ImageData(new Uint8ClampedArray(src), w, h);
  ctx.putImageData(out, 0, 0);
}

// helpers
function clamp(v){
  if(v < 0) return 0;
  if(v > 255) return 255;
  return Math.round(v);
}
function gammaClamp(v){
  // apply small gamma to open shadows slightly
  let g = 1/1.05;
  let nv = Math.pow((v/255), g) * 255;
  return clamp(nv);
}

// Download
document.getElementById('download').addEventListener('click', ()=>{
  if(!originalImageData) return alert('First choose an image');
  const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = 'reveal_result.jpg';
  a.click();
});

// initial note: if user opens file by direct image (drag), we still need to load file input
// (We intentionally made this single-file; no external libs)

</script>

</body>
</html>
